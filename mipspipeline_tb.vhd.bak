library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_signed.all;
use ieee.numeric_std.all;

entity mipspipeline_tb is
end mipspipeline_tb;

architecture mipspipeline_tb_arch of mipspipeline_tb is
component mipspipeline is
	port (
		clk : in std_logic;
		saida_Muxpc : out std_logic_Vector(31 downto 0);
		saida_MI : out std_logic_Vector(31 downto 0);
		saida_BREGrs : out std_logic_Vector(31 downto 0);
		saida_BREGrt : out std_logic_Vector(31 downto 0);
		saidaWB : out std_logic_Vector(2 downto 0);
		saidaEX : out std_logic_Vector(8 downto 0);
		saidaM : out std_logic_Vector(1 downto 0);
		saidaULA : out std_logic_Vector(31 downto 0);
		saidaMUXindice : out std_logic_Vector(4 downto 0);
		saidaMD : out std_logic_Vector(31 downto 0);
		saidaMUXdado : out std_logic_Vector(31 downto 0)
		);
end component;

signal clk : std_logic;
signal saida_Muxpc : std_logic_Vector(31 downto 0);
signal saida_MI : std_logic_Vector(31 downto 0);
signal saida_BREGrs : std_logic_Vector(31 downto 0);
signal saida_BREGrt : std_logic_Vector(31 downto 0);
signal saidaWB : std_logic_Vector(2 downto 0);
signal saidaEX : std_logic_Vector(8 downto 0);
signal saidaM : std_logic_Vector(1 downto 0);
signal saidaULA : std_logic_Vector(31 downto 0);
signal saidaMUXindice : std_logic_Vector(4 downto 0);
signal saidaMD : std_logic_Vector(31 downto 0);
signal saidaMUXdado : std_logic_Vector(31 downto 0)


begin
	mipspipelineTB : mipspipeline
	PORT MAP (
		clk => clk,
		saida_Muxpc => saida_Muxpc,
		saida_MI => saida_MI,
		saida_BREGrs=> saida_BREGrs,
		saida_BREGrt=> saida_BREGrt,
		saidaWB=> saidaWB,
		saidaEX=> saidaEX,
		saidaM=> saidaM,
		saidaULA=> saidaULA,
		saidaMUXindice=> saidaMUXindice,
		saidaMD=> saidaMD,
		saidaMUXdado=> saidaMUXdado
	);

Init : process
	begin
	clk <= '1';
	wait for 0.5 ns;
	clk <= '0';
	wait for 0.5 ns;

end process;
end mipspipeline_tb_arch;
